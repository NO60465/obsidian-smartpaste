/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// main.ts
__export(exports, {
  default: () => ObsidianCutPlugin
});
var import_obsidian5 = __toModule(require("obsidian"));

// src/utils/constants.ts
var DEFAULT_SETTINGS = {
  selectedFiles: [],
  selectedFileIndex: 0,
  pasteFormat: "newline",
  autoShowPanel: true,
  fixedPanel: false,
  panelPosition: { x: 100, y: 100 },
  openFileHotkey: "Ctrl+Click",
  copyToFileHotkey: "Ctrl+Shift+X",
  panelWidth: 300,
  panelHeight: 400,
  fileSortOrder: "name",
  showFileExtensions: false,
  contentSortRules: {
    enabled: true,
    sortBy: "alphabetical",
    removeDuplicates: true,
    trimWhitespace: true
  }
};
var PASTE_FORMATS = {
  newline: {
    name: "\u539F\u683C\u5F0F",
    template: "{content}"
  },
  "unordered-list": {
    name: "\u65E0\u5E8F\u53F7\u5217\u8868",
    template: "- {content}"
  },
  "ordered-list": {
    name: "\u6709\u5E8F\u53F7\u5217\u8868",
    template: "{index}. {content}"
  },
  plain: {
    name: "\u7EAF\u6587\u672C",
    template: "plain"
  }
};
var CONTENT_SORT_OPTIONS = {
  alphabetical: "\u6309\u5B57\u6BCD\u987A\u5E8F",
  length: "\u6309\u957F\u5EA6",
  date: "\u6309\u65E5\u671F"
};

// src/settings/SettingsTab.ts
var import_obsidian = __toModule(require("obsidian"));
var import_obsidian2 = __toModule(require("obsidian"));
var ObsidianCutSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Obsidian SmartPaste \u8BBE\u7F6E" });
    this.createFileSelectionSettings(containerEl);
    this.createPasteFormatSettings(containerEl);
    this.createPanelSettings(containerEl);
    this.createHotkeySettings(containerEl);
    this.createContentOrganizationSettings(containerEl);
  }
  createFileSelectionSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u6587\u4EF6\u9009\u62E9" });
    new import_obsidian.Setting(containerEl).setName("\u5DF2\u9009\u62E9\u7684\u6587\u4EF6").setDesc("\u5728\u60AC\u6D6E\u7A97\u4E2D\u663E\u793A\u7684\u6587\u4EF6\u5217\u8868").addButton((button) => {
      button.setButtonText("\u7BA1\u7406\u6587\u4EF6\u5217\u8868");
      button.onClick(async () => {
        await this.showFileSelector();
      });
    });
    if (this.plugin.settings.selectedFiles.length > 0) {
      const fileListContainer = containerEl.createEl("div");
      fileListContainer.addClass("obsidian-smartpaste-selected-files-container");
      const title = fileListContainer.createEl("h4", {
        text: `\u5DF2\u9009\u62E9\u7684\u6587\u4EF6 (${this.plugin.settings.selectedFiles.length})`
      });
      title.addClass("obsidian-smartpaste-selected-files-title");
      const fileGrid = fileListContainer.createEl("div");
      fileGrid.addClass("obsidian-smartpaste-file-grid");
      this.plugin.settings.selectedFiles.forEach((filePath, index) => {
        var _a;
        const fileCard = fileGrid.createEl("div");
        fileCard.addClass("obsidian-smartpaste-file-card");
        const fileIcon = fileCard.createEl("div");
        fileIcon.addClass("obsidian-smartpaste-file-card-icon");
        fileIcon.innerHTML = "\u{1F4C4}";
        const fileInfo = fileCard.createEl("div");
        fileInfo.addClass("obsidian-smartpaste-file-card-info");
        const fileName = fileInfo.createEl("div");
        fileName.addClass("obsidian-smartpaste-file-card-name");
        fileName.textContent = ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || filePath;
        const actions = fileCard.createEl("div");
        actions.addClass("obsidian-smartpaste-file-card-actions");
        const removeButton = actions.createEl("button");
        removeButton.addClass("obsidian-smartpaste-file-card-button");
        removeButton.innerHTML = "\u{1F5D1}\uFE0F";
        removeButton.title = "\u4ECE\u5217\u8868\u4E2D\u79FB\u9664";
        removeButton.onclick = async () => {
          this.plugin.settings.selectedFiles.splice(index, 1);
          await this.plugin.saveSettings();
          this.display();
        };
      });
    }
  }
  createPasteFormatSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u7C98\u8D34\u683C\u5F0F" });
    new import_obsidian.Setting(containerEl).setName("\u9ED8\u8BA4\u7C98\u8D34\u683C\u5F0F").setDesc("\u9009\u62E9\u5185\u5BB9\u7C98\u8D34\u5230\u6587\u4EF6\u65F6\u7684\u9ED8\u8BA4\u683C\u5F0F").addDropdown((dropdown) => {
      Object.entries(PASTE_FORMATS).forEach(([key, value]) => {
        dropdown.addOption(key, value.name);
      });
      dropdown.setValue(this.plugin.settings.pasteFormat);
      dropdown.onChange(async (value) => {
        this.plugin.settings.pasteFormat = value;
        await this.plugin.saveSettings();
      });
    });
  }
  createPanelSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u60AC\u6D6E\u7A97\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u81EA\u52A8\u663E\u793A\u60AC\u6D6E\u7A97").setDesc("\u9009\u4E2D\u6587\u672C\u65F6\u81EA\u52A8\u663E\u793A\u60AC\u6D6E\u7A97").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.autoShowPanel);
      toggle.onChange(async (value) => {
        this.plugin.settings.autoShowPanel = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u60AC\u6D6E\u7A97\u5BBD\u5EA6").setDesc("\u8BBE\u7F6E\u60AC\u6D6E\u7A97\u7684\u5BBD\u5EA6\uFF08\u50CF\u7D20\uFF09").addSlider((slider) => {
      slider.setLimits(200, 600, 50);
      slider.setValue(this.plugin.settings.panelWidth);
      slider.setDynamicTooltip();
      slider.onChange(async (value) => {
        this.plugin.settings.panelWidth = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u60AC\u6D6E\u7A97\u9AD8\u5EA6").setDesc("\u8BBE\u7F6E\u60AC\u6D6E\u7A97\u7684\u9AD8\u5EA6\uFF08\u50CF\u7D20\uFF09").addSlider((slider) => {
      slider.setLimits(200, 800, 50);
      slider.setValue(this.plugin.settings.panelHeight);
      slider.setDynamicTooltip();
      slider.onChange(async (value) => {
        this.plugin.settings.panelHeight = value;
        await this.plugin.saveSettings();
      });
    });
  }
  createHotkeySettings(containerEl) {
    containerEl.createEl("h3", { text: "\u5FEB\u6377\u952E\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u6253\u5F00\u6587\u4EF6\u5FEB\u6377\u952E").setDesc("\u8BBE\u7F6E\u4EE5\u5206\u5C4F\u65B9\u5F0F\u6253\u5F00\u6587\u4EF6\u7684\u5FEB\u6377\u952E").addText((text) => {
      text.setValue(this.plugin.settings.openFileHotkey);
      text.onChange(async (value) => {
        this.plugin.settings.openFileHotkey = value;
        await this.plugin.saveSettings();
      });
    });
  }
  isValidHotkey(hotkey) {
    if (!hotkey || !hotkey.trim())
      return false;
    const parts = hotkey.split("+").map((part) => part.trim());
    if (parts.length < 2)
      return false;
    const validModifiers = ["ctrl", "cmd", "command", "alt", "shift"];
    const validKeys = /^[a-zA-Z0-9]$/;
    for (let i = 0; i < parts.length - 1; i++) {
      if (!validModifiers.includes(parts[i].toLowerCase())) {
        return false;
      }
    }
    const mainKey = parts[parts.length - 1];
    return validKeys.test(mainKey);
  }
  createContentOrganizationSettings(containerEl) {
    containerEl.createEl("h3", { text: "\u5185\u5BB9\u6574\u7406\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("\u542F\u7528\u5185\u5BB9\u6574\u7406").setDesc("\u542F\u7528\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u529F\u80FD").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.contentSortRules.enabled);
      toggle.onChange(async (value) => {
        this.plugin.settings.contentSortRules.enabled = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u5185\u5BB9\u6392\u5E8F\u65B9\u5F0F").setDesc("\u9009\u62E9\u5185\u5BB9\u6574\u7406\u65F6\u7684\u6392\u5E8F\u65B9\u5F0F").addDropdown((dropdown) => {
      Object.entries(CONTENT_SORT_OPTIONS).forEach(([key, value]) => {
        dropdown.addOption(key, value);
      });
      dropdown.setValue(this.plugin.settings.contentSortRules.sortBy);
      dropdown.onChange(async (value) => {
        this.plugin.settings.contentSortRules.sortBy = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u53BB\u9664\u91CD\u590D\u5185\u5BB9").setDesc("\u6574\u7406\u5185\u5BB9\u65F6\u53BB\u9664\u91CD\u590D\u7684\u884C").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.contentSortRules.removeDuplicates);
      toggle.onChange(async (value) => {
        this.plugin.settings.contentSortRules.removeDuplicates = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("\u53BB\u9664\u9996\u5C3E\u7A7A\u683C").setDesc("\u6574\u7406\u5185\u5BB9\u65F6\u53BB\u9664\u6BCF\u884C\u7684\u9996\u5C3E\u7A7A\u683C").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.contentSortRules.trimWhitespace);
      toggle.onChange(async (value) => {
        this.plugin.settings.contentSortRules.trimWhitespace = value;
        await this.plugin.saveSettings();
      });
    });
  }
  async showFileSelector() {
    try {
      console.log("Opening file selector...");
      const files = this.app.vault.getMarkdownFiles();
      const availableFiles = files.filter((f) => !this.plugin.settings.selectedFiles.includes(f.path));
      if (availableFiles.length === 0) {
        new import_obsidian2.Notice("\u6CA1\u6709\u53EF\u9009\u62E9\u7684\u6587\u4EF6");
        return;
      }
      const modal = new import_obsidian.Modal(this.app);
      modal.titleEl.setText("\u9009\u62E9\u8981\u6DFB\u52A0\u7684\u6587\u4EF6");
      modal.containerEl.addClass("obsidian-smartpaste-file-selector");
      const content = modal.contentEl;
      content.empty();
      const description = content.createEl("p", {
        text: "\u70B9\u51FB\u6587\u4EF6\u5939\u5C55\u5F00/\u6298\u53E0\uFF0C\u70B9\u51FB\u6587\u4EF6\u9009\u62E9/\u53D6\u6D88\u9009\u62E9\uFF1A"
      });
      description.addClass("obsidian-smartpaste-description");
      const searchContainer = content.createEl("div");
      searchContainer.addClass("obsidian-smartpaste-search-container");
      const searchInput = searchContainer.createEl("input", {
        type: "text"
      });
      searchInput.setAttribute("placeholder", "\u641C\u7D22\u6587\u4EF6\u6216\u6587\u4EF6\u5939...");
      searchInput.addClass("obsidian-smartpaste-search-input");
      const fileListContainer = content.createEl("div");
      fileListContainer.addClass("obsidian-smartpaste-file-list-container");
      const selectedFiles = new Set();
      const buildFolderTree = (files2) => {
        const tree = {};
        files2.forEach((file) => {
          const pathParts = file.path.split("/");
          let currentLevel = tree;
          for (let i = 0; i < pathParts.length - 1; i++) {
            const folderName = pathParts[i];
            if (!currentLevel[folderName]) {
              currentLevel[folderName] = { type: "folder", children: {} };
            }
            currentLevel = currentLevel[folderName].children;
          }
          const fileName = pathParts[pathParts.length - 1];
          currentLevel[fileName] = { type: "file", data: file };
        });
        return tree;
      };
      const renderFolderTree = (tree, container, level = 0) => {
        const sortedKeys = Object.keys(tree).sort((a, b) => {
          const aIsFolder = tree[a].type === "folder";
          const bIsFolder = tree[b].type === "folder";
          if (aIsFolder && !bIsFolder)
            return -1;
          if (!aIsFolder && bIsFolder)
            return 1;
          return a.localeCompare(b);
        });
        sortedKeys.forEach((key) => {
          const item = tree[key];
          if (item.type === "folder") {
            const folderItem = container.createEl("div");
            folderItem.addClass("obsidian-smartpaste-folder-item");
            const folderHeader = folderItem.createEl("div");
            folderHeader.addClass("obsidian-smartpaste-folder-header");
            folderHeader.style.cursor = "pointer";
            folderHeader.style.paddingLeft = `${level * 20}px`;
            const folderIcon = folderHeader.createEl("span", {
              text: "\u{1F4C1}"
            });
            folderIcon.addClass("obsidian-smartpaste-folder-icon");
            const folderName = folderHeader.createEl("span", {
              text: key
            });
            folderName.addClass("obsidian-smartpaste-folder-name");
            const countFiles = (children) => {
              let count = 0;
              Object.values(children).forEach((child) => {
                if (child.type === "file") {
                  count++;
                } else if (child.type === "folder") {
                  count += countFiles(child.children);
                }
              });
              return count;
            };
            const fileCount = folderHeader.createEl("span", {
              text: ` (${countFiles(item.children)})`
            });
            fileCount.addClass("obsidian-smartpaste-file-count");
            const folderChildren = folderItem.createEl("div");
            folderChildren.addClass("obsidian-smartpaste-folder-children");
            folderChildren.style.display = "none";
            renderFolderTree(item.children, folderChildren, level + 1);
            folderHeader.onclick = () => {
              const isExpanded = folderChildren.style.display !== "none";
              folderChildren.style.display = isExpanded ? "none" : "block";
              folderIcon.textContent = isExpanded ? "\u{1F4C1}" : "\u{1F4C2}";
            };
            folderItem.appendChild(folderChildren);
          } else if (item.type === "file") {
            const fileItem = container.createEl("div");
            fileItem.addClass("obsidian-smartpaste-file-item");
            fileItem.style.paddingLeft = `${level * 20}px`;
            const fileIcon = fileItem.createEl("span", {
              text: "\u{1F4C4}"
            });
            fileIcon.addClass("obsidian-smartpaste-file-icon");
            const fileName = fileItem.createEl("span", {
              text: key.replace(".md", "")
            });
            fileName.addClass("obsidian-smartpaste-file-name");
            fileItem.onclick = () => {
              if (selectedFiles.has(item.data.path)) {
                selectedFiles.delete(item.data.path);
                fileItem.classList.remove("selected");
              } else {
                selectedFiles.add(item.data.path);
                fileItem.classList.add("selected");
              }
              addButton.setText(`\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6 (${selectedFiles.size})`);
            };
          }
        });
      };
      const renderFileList = (filterText = "") => {
        fileListContainer.empty();
        const filteredFiles = availableFiles.filter((file) => file.basename.toLowerCase().includes(filterText.toLowerCase()) || file.path.toLowerCase().includes(filterText.toLowerCase()));
        if (filteredFiles.length === 0) {
          const noFiles = fileListContainer.createEl("div", {
            text: filterText ? "\u6CA1\u6709\u627E\u5230\u5339\u914D\u7684\u6587\u4EF6" : "\u6CA1\u6709\u53EF\u9009\u62E9\u7684\u6587\u4EF6"
          });
          noFiles.addClass("obsidian-smartpaste-no-files");
          return;
        }
        const folderTree = buildFolderTree(filteredFiles);
        renderFolderTree(folderTree, fileListContainer);
      };
      renderFileList();
      searchInput.addEventListener("input", (e) => {
        const target = e.target;
        renderFileList(target.value);
      });
      const buttonContainer = content.createEl("div");
      buttonContainer.addClass("obsidian-smartpaste-button-container");
      const selectAllButton = buttonContainer.createEl("button", {
        text: "\u5168\u9009"
      });
      selectAllButton.addClass("obsidian-smartpaste-select-all-button");
      selectAllButton.onclick = () => {
        const fileItems = fileListContainer.querySelectorAll(".obsidian-smartpaste-file-item");
        fileItems.forEach((fileItem) => {
          var _a;
          const fileName = (_a = fileItem.querySelector(".obsidian-smartpaste-file-name")) == null ? void 0 : _a.textContent;
          if (fileName) {
            const file = availableFiles.find((f) => f.basename === fileName);
            if (file) {
              selectedFiles.add(file.path);
              fileItem.classList.add("selected");
            }
          }
        });
        addButton.setText(`\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6 (${selectedFiles.size})`);
      };
      const deselectAllButton = buttonContainer.createEl("button", {
        text: "\u53D6\u6D88\u5168\u9009"
      });
      deselectAllButton.addClass("obsidian-smartpaste-deselect-all-button");
      deselectAllButton.onclick = () => {
        const fileItems = fileListContainer.querySelectorAll(".obsidian-smartpaste-file-item");
        fileItems.forEach((fileItem) => {
          fileItem.classList.remove("selected");
        });
        selectedFiles.clear();
        addButton.setText(`\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6 (${selectedFiles.size})`);
      };
      const addButton = buttonContainer.createEl("button", {
        text: `\u6DFB\u52A0\u9009\u4E2D\u6587\u4EF6 (${selectedFiles.size})`
      });
      addButton.addClass("obsidian-smartpaste-add-button");
      addButton.onclick = async () => {
        if (selectedFiles.size === 0) {
          new import_obsidian2.Notice("\u8BF7\u5148\u9009\u62E9\u6587\u4EF6");
          return;
        }
        try {
          let addedCount = 0;
          for (const filePath of selectedFiles) {
            if (!this.plugin.settings.selectedFiles.includes(filePath)) {
              this.plugin.settings.selectedFiles.push(filePath);
              addedCount++;
            }
          }
          await this.plugin.saveSettings();
          new import_obsidian2.Notice(`\u5DF2\u6DFB\u52A0 ${addedCount} \u4E2A\u6587\u4EF6`);
          modal.close();
          this.display();
        } catch (error) {
          console.error("\u6DFB\u52A0\u6587\u4EF6\u5931\u8D25:", error);
          new import_obsidian2.Notice("\u6DFB\u52A0\u6587\u4EF6\u5931\u8D25");
        }
      };
      const closeButton = buttonContainer.createEl("button", {
        text: "\u5173\u95ED"
      });
      closeButton.addClass("obsidian-smartpaste-close-button");
      closeButton.onclick = () => modal.close();
      modal.open();
      console.log("File selector modal opened successfully");
    } catch (error) {
      console.error("\u6253\u5F00\u6587\u4EF6\u9009\u62E9\u5668\u5931\u8D25:", error);
      new import_obsidian2.Notice("\u6253\u5F00\u6587\u4EF6\u9009\u62E9\u5668\u5931\u8D25");
    }
  }
};

// src/services/FileManager.ts
var import_obsidian3 = __toModule(require("obsidian"));
var FileManager = class {
  constructor(app) {
    this.app = app;
  }
  async getAllFiles() {
    const files = this.app.vault.getMarkdownFiles();
    const fileInfos = [];
    for (const file of files) {
      const fileInfo = await this.getFileInfo(file);
      fileInfos.push(fileInfo);
    }
    return fileInfos;
  }
  async getFileInfo(file) {
    const stat = await this.app.vault.adapter.stat(file.path);
    const basename = file.basename;
    const extension = file.extension;
    return {
      path: file.path,
      name: file.name,
      basename,
      extension,
      modifiedTime: stat.mtime,
      createdTime: stat.ctime,
      size: stat.size
    };
  }
  sortFiles(files, sortOrder) {
    const sortedFiles = [...files];
    switch (sortOrder) {
      case "name":
        sortedFiles.sort((a, b) => a.basename.localeCompare(b.basename));
        break;
      case "modified":
        sortedFiles.sort((a, b) => b.modifiedTime - a.modifiedTime);
        break;
      case "created":
        sortedFiles.sort((a, b) => b.createdTime - a.createdTime);
        break;
    }
    return sortedFiles;
  }
  filterSelectedFiles(allFiles, selectedFiles) {
    return allFiles.filter((file) => !selectedFiles.includes(file.path));
  }
  async getSelectedFileInfos(selectedPaths) {
    const fileInfos = [];
    for (const path of selectedPaths) {
      const file = this.app.vault.getAbstractFileByPath(path);
      if (file instanceof import_obsidian3.TFile) {
        const fileInfo = await this.getFileInfo(file);
        fileInfos.push(fileInfo);
      }
    }
    return fileInfos;
  }
  async createNewFile(folderPath, fileName) {
    try {
      const fullPath = folderPath ? `${folderPath}/${fileName}.md` : `${fileName}.md`;
      const file = await this.app.vault.create(fullPath, "");
      return file;
    } catch (error) {
      console.error("\u521B\u5EFA\u6587\u4EF6\u5931\u8D25:", error);
      return null;
    }
  }
  async appendToFile(filePath, content) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian3.TFile)) {
        return false;
      }
      const currentContent = await this.app.vault.read(file);
      const newContent = currentContent + "\n" + content;
      await this.app.vault.modify(file, newContent);
      return true;
    } catch (error) {
      console.error("\u8FFD\u52A0\u5185\u5BB9\u5931\u8D25:", error);
      return false;
    }
  }
  async replaceFileContent(filePath, content) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian3.TFile)) {
        return false;
      }
      await this.app.vault.modify(file, content);
      return true;
    } catch (error) {
      console.error("\u66FF\u6362\u5185\u5BB9\u5931\u8D25:", error);
      return false;
    }
  }
  async readFileContent(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian3.TFile)) {
        return "";
      }
      return await this.app.vault.read(file);
    } catch (error) {
      console.error("\u8BFB\u53D6\u6587\u4EF6\u5931\u8D25:", error);
      return "";
    }
  }
  searchFiles(files, searchText) {
    if (!searchText.trim()) {
      return files;
    }
    const searchLower = searchText.toLowerCase();
    return files.filter((file) => file.basename.toLowerCase().includes(searchLower) || file.path.toLowerCase().includes(searchLower));
  }
  getFolders() {
    return this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian3.TFolder);
  }
  fileExists(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    return file instanceof import_obsidian3.TFile;
  }
  formatFileSize(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
  }
  getRelativeTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const seconds = Math.floor(diff / 1e3);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (days > 0) {
      return `${days}\u5929\u524D`;
    } else if (hours > 0) {
      return `${hours}\u5C0F\u65F6\u524D`;
    } else if (minutes > 0) {
      return `${minutes}\u5206\u949F\u524D`;
    } else {
      return "\u521A\u521A";
    }
  }
};

// src/services/ContentFormatter.ts
var ContentFormatter = class {
  static formatContent(content, options) {
    var _a;
    const { format, customTemplate, addTimestamp, addSource } = options;
    console.log("ContentFormatter.formatContent - \u8F93\u5165\u5185\u5BB9:", content);
    console.log("ContentFormatter.formatContent - \u8F93\u5165\u5185\u5BB9\u957F\u5EA6:", content.length);
    console.log("ContentFormatter.formatContent - \u8F93\u5165\u5185\u5BB9\u5305\u542B\u6362\u884C\u7B26:", content.includes("\n"));
    console.log("ContentFormatter.formatContent - \u8F93\u5165\u5185\u5BB9\u6362\u884C\u7B26\u4F4D\u7F6E:", content.split("").map((char, index) => char === "\n" ? index : -1).filter((pos) => pos !== -1));
    console.log("ContentFormatter.formatContent - \u683C\u5F0F\u9009\u9879:", format);
    let formattedContent;
    if (format === "plain") {
      formattedContent = this.stripMarkdownFormatting(content);
      formattedContent = this.cleanContent(formattedContent);
    } else if (format === "unordered-list" || format === "ordered-list") {
      console.log("ContentFormatter.formatContent - \u5904\u7406\u5217\u8868\u683C\u5F0F");
      formattedContent = this.stripMarkdownFormatting(content);
      console.log("ContentFormatter.formatContent - \u53BB\u9664Markdown\u683C\u5F0F\u540E:", formattedContent);
      formattedContent = this.cleanContent(formattedContent);
      console.log("ContentFormatter.formatContent - \u6E05\u7406\u540E:", formattedContent);
    } else {
      formattedContent = this.cleanContent(content);
    }
    if (customTemplate) {
      formattedContent = this.applyCustomTemplate(formattedContent, customTemplate);
    } else {
      const formatTemplate = ((_a = PASTE_FORMATS[format]) == null ? void 0 : _a.template) || PASTE_FORMATS.newline.template;
      formattedContent = this.applyTemplate(formattedContent, formatTemplate);
    }
    if (addTimestamp) {
      formattedContent = this.addTimestamp(formattedContent);
    }
    if (addSource) {
      formattedContent = this.addSource(formattedContent);
    }
    return formattedContent;
  }
  static formatContentWithContinuousNumbering(content, options, existingContent) {
    var _a;
    const { format, customTemplate, addTimestamp, addSource } = options;
    console.log("ContentFormatter.formatContentWithContinuousNumbering - \u8F93\u5165\u5185\u5BB9:", content);
    console.log("ContentFormatter.formatContentWithContinuousNumbering - \u73B0\u6709\u5185\u5BB9:", existingContent);
    let formattedContent;
    if (format === "plain") {
      formattedContent = this.stripMarkdownFormatting(content);
      formattedContent = this.cleanContent(formattedContent);
    } else if (format === "unordered-list" || format === "ordered-list") {
      console.log("ContentFormatter.formatContentWithContinuousNumbering - \u5904\u7406\u5217\u8868\u683C\u5F0F");
      formattedContent = this.stripMarkdownFormatting(content);
      console.log("ContentFormatter.formatContentWithContinuousNumbering - \u53BB\u9664Markdown\u683C\u5F0F\u540E:", formattedContent);
      formattedContent = this.cleanContent(formattedContent);
      console.log("ContentFormatter.formatContentWithContinuousNumbering - \u6E05\u7406\u540E:", formattedContent);
    } else {
      formattedContent = this.cleanContent(content);
    }
    if (customTemplate) {
      formattedContent = this.applyCustomTemplate(formattedContent, customTemplate);
    } else {
      const formatTemplate = ((_a = PASTE_FORMATS[format]) == null ? void 0 : _a.template) || PASTE_FORMATS.newline.template;
      if (format === "ordered-list" && existingContent) {
        formattedContent = this.applyTemplateWithContinuousNumbering(formattedContent, formatTemplate, existingContent);
      } else {
        formattedContent = this.applyTemplate(formattedContent, formatTemplate);
      }
    }
    if (addTimestamp) {
      formattedContent = this.addTimestamp(formattedContent);
    }
    if (addSource) {
      formattedContent = this.addSource(formattedContent);
    }
    return formattedContent;
  }
  static cleanContent(content) {
    return content.trim().replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  }
  static stripMarkdownFormatting(content) {
    return content.replace(/\*\*(.*?)\*\*/g, "$1").replace(/__(.*?)__/g, "$1").replace(/\*(.*?)\*/g, "$1").replace(/_(.*?)_/g, "$1").replace(/~~(.*?)~~/g, "$1").replace(/`(.*?)`/g, "$1").replace(/\[([^\]]*)\]\([^)]*\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]*\)/g, "$1").replace(/^#{1,6}\s+/gm, "").replace(/^[\s]*[-*+]\s+/gm, "").replace(/^[\s]*\d+\.\s+/gm, "").replace(/^>\s+/gm, "").replace(/^```[\s\S]*?```$/gm, "").replace(/^\|.*\|$/gm, "").replace(/^[-*]{3,}$/gm, "").replace(/\[\^[^\]]*\]/g, "").replace(/^[\s]*-\s+\[[\sx]\]\s+/gm, "").replace(/\n\s*\n\s*\n/g, "\n\n").replace(/^\s+|\s+$/gm, "");
  }
  static applyTemplate(content, template) {
    console.log("ContentFormatter.applyTemplate - \u8F93\u5165\u5185\u5BB9:", content);
    console.log("ContentFormatter.applyTemplate - \u8F93\u5165\u6A21\u677F:", template);
    if (template.includes("{content}")) {
      if (template === "{index}. {content}") {
        console.log("ContentFormatter.applyTemplate - \u5904\u7406\u6709\u5E8F\u5217\u8868");
        const lines = content.split("\n").filter((line) => line.trim());
        console.log("ContentFormatter.applyTemplate - \u8FC7\u6EE4\u540E\u7684\u884C\u6570:", lines.length);
        console.log("ContentFormatter.applyTemplate - \u8FC7\u6EE4\u540E\u7684\u884C:", lines);
        const result = lines.map((line, index) => {
          const replaced = template.replace("{index}", (index + 1).toString()).replace("{content}", line);
          console.log(`ContentFormatter.applyTemplate - \u7B2C${index + 1}\u884C: "${line}" -> "${replaced}"`);
          return replaced;
        }).join("\n");
        console.log("ContentFormatter.applyTemplate - \u6709\u5E8F\u5217\u8868\u6700\u7EC8\u7ED3\u679C:", result);
        return result;
      } else if (template === "- {content}") {
        console.log("ContentFormatter.applyTemplate - \u5904\u7406\u65E0\u5E8F\u5217\u8868");
        const lines = content.split("\n").filter((line) => line.trim());
        return lines.map((line) => {
          return template.replace("{content}", line);
        }).join("\n");
      } else if (template === "{content}") {
        console.log("ContentFormatter.applyTemplate - \u5904\u7406\u539F\u683C\u5F0F");
        const lines = content.split("\n");
        return lines.map((line) => line.trim()).filter((line) => line).join("\n");
      } else if (template === "plain") {
        console.log("ContentFormatter.applyTemplate - \u5904\u7406\u7EAF\u6587\u672C\u683C\u5F0F");
        return content;
      } else {
        console.log("ContentFormatter.applyTemplate - \u5904\u7406\u5176\u4ED6\u683C\u5F0F");
        const lines = content.split("\n").filter((line) => line.trim());
        return lines.map((line) => template.replace("{content}", line)).join("\n");
      }
    }
    console.log("ContentFormatter.applyTemplate - \u8FDB\u5165\u9ED8\u8BA4\u5206\u652F");
    return template + content;
  }
  static applyTemplateWithContinuousNumbering(content, template, existingContent) {
    console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u8F93\u5165\u5185\u5BB9:", content);
    console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u8F93\u5165\u6A21\u677F:", template);
    console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u73B0\u6709\u5185\u5BB9:", existingContent);
    if (template.includes("{content}")) {
      if (template === "{index}. {content}") {
        console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u5904\u7406\u6709\u5E8F\u5217\u8868");
        const lines = content.split("\n").filter((line) => line.trim());
        console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u8FC7\u6EE4\u540E\u7684\u884C\u6570:", lines.length);
        console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u8FC7\u6EE4\u540E\u7684\u884C:", lines);
        const nextIndex = this.getNextOrderedListIndex(existingContent);
        console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u4E0B\u4E00\u4E2A\u5E8F\u53F7:", nextIndex);
        const result = lines.map((line, index) => {
          const currentIndex = nextIndex + index;
          const replaced = template.replace("{index}", currentIndex.toString()).replace("{content}", line);
          console.log(`ContentFormatter.applyTemplateWithContinuousNumbering - \u7B2C${currentIndex}\u884C: "${line}" -> "${replaced}"`);
          return replaced;
        }).join("\n");
        console.log("ContentFormatter.applyTemplateWithContinuousNumbering - \u6709\u5E8F\u5217\u8868\u6700\u7EC8\u7ED3\u679C:", result);
        return result;
      } else {
        return this.applyTemplate(content, template);
      }
    }
    return template + content;
  }
  static getNextOrderedListIndex(existingContent) {
    if (!existingContent)
      return 1;
    const orderedListPattern = /^\s*(\d+)\.\s+/gm;
    const matches = [...existingContent.matchAll(orderedListPattern)];
    if (matches.length === 0) {
      return 1;
    }
    const maxIndex = Math.max(...matches.map((match) => parseInt(match[1])));
    console.log("ContentFormatter.getNextOrderedListIndex - \u73B0\u6709\u6700\u5927\u5E8F\u53F7:", maxIndex);
    return maxIndex + 1;
  }
  static applyCustomTemplate(content, template) {
    const lines = content.split("\n").filter((line) => line.trim());
    return lines.map((line) => {
      return template.replace("{content}", line).replace("{timestamp}", new Date().toISOString()).replace("{date}", new Date().toLocaleDateString()).replace("{time}", new Date().toLocaleTimeString());
    }).join("");
  }
  static addTimestamp(content) {
    const timestamp = new Date().toLocaleString();
    return `<!-- Added: ${timestamp} -->
${content}`;
  }
  static addSource(content) {
    const source = `<!-- Source: ${window.location.href} -->
`;
    return source + content;
  }
  static organizeContent(content, rules) {
    let lines = content.split("\n");
    console.log("\u539F\u59CB\u884C\u6570:", lines.length);
    if (rules.trimWhitespace) {
      lines = lines.map((line) => line.trim());
    }
    if (rules.removeDuplicates) {
      const uniqueLines = [];
      const seen = new Set();
      for (const line of lines) {
        if (!seen.has(line)) {
          seen.add(line);
          uniqueLines.push(line);
        }
      }
      lines = uniqueLines;
      console.log("\u53BB\u91CD\u540E\u884C\u6570:", lines.length);
    }
    const nonEmptyLines = lines.filter((line) => line.trim());
    const emptyLines = lines.filter((line) => !line.trim());
    switch (rules.sortBy) {
      case "alphabetical":
        nonEmptyLines.sort((a, b) => a.localeCompare(b));
        break;
      case "length":
        nonEmptyLines.sort((a, b) => a.length - b.length);
        break;
      case "date":
        nonEmptyLines.sort((a, b) => {
          const dateA = this.extractDate(a);
          const dateB = this.extractDate(b);
          if (dateA && dateB) {
            return dateA.getTime() - dateB.getTime();
          }
          return a.localeCompare(b);
        });
        break;
    }
    const result = [...nonEmptyLines, ...emptyLines].join("\n");
    console.log("\u6574\u7406\u540E\u5185\u5BB9\u957F\u5EA6:", result.length);
    return result;
  }
  static extractDate(text) {
    const datePatterns = [
      /\d{4}-\d{2}-\d{2}/,
      /\d{2}\/\d{2}\/\d{4}/,
      /\d{2}-\d{2}-\d{4}/,
      /\d{4}\/\d{2}\/\d{2}/
    ];
    for (const pattern of datePatterns) {
      const match = text.match(pattern);
      if (match) {
        const date = new Date(match[0]);
        if (!isNaN(date.getTime())) {
          return date;
        }
      }
    }
    return null;
  }
  static detectContentType(content) {
    const lines = content.split("\n").filter((line) => line.trim());
    if (lines.length === 0)
      return "text";
    const hasListItems = lines.some((line) => /^[\-\*\+]\s/.test(line) || /^\d+\.\s/.test(line));
    const hasCodeBlocks = lines.some((line) => line.startsWith("```") || line.startsWith("`"));
    const hasCodeIndentation = lines.some((line) => /^\s{4,}/.test(line));
    if (hasCodeBlocks || hasCodeIndentation)
      return "code";
    if (hasListItems)
      return "list";
    return "mixed";
  }
};

// src/services/HotkeyManager.ts
var HotkeyManager = class {
  constructor(app, settings) {
    this.registeredHotkeys = new Map();
    this.app = app;
    this.settings = settings;
  }
  registerHotkeys() {
    console.log("HotkeyManager: \u8DF3\u8FC7\u5FEB\u6377\u952E\u6CE8\u518C\uFF0C\u4F7F\u7528\u4E8B\u4EF6\u76D1\u542C\u5668");
  }
  unregisterHotkeys() {
    this.registeredHotkeys.clear();
  }
  registerPanelToggleHotkey() {
    const hotkeyId = "obsidian-smartpaste-toggle-panel";
    console.log("HotkeyManager: \u6CE8\u518C\u60AC\u6D6E\u7A97\u5207\u6362\u4E8B\u4EF6\u76D1\u542C\u5668");
  }
  registerFileOpenHotkey() {
    const hotkeyId = "obsidian-smartpaste-open-file";
    console.log("HotkeyManager: \u6CE8\u518C\u6587\u4EF6\u6253\u5F00\u4E8B\u4EF6\u76D1\u542C\u5668");
  }
  updateHotkeys(newSettings) {
    this.settings = newSettings;
    this.unregisterHotkeys();
    this.registerHotkeys();
  }
  static parseHotkey(hotkeyString) {
    try {
      const parts = hotkeyString.split("+");
      const key = parts.pop();
      const modifiers = parts.map((mod) => {
        switch (mod.toLowerCase()) {
          case "ctrl":
          case "control":
            return "Ctrl";
          case "alt":
            return "Alt";
          case "shift":
            return "Shift";
          case "meta":
          case "cmd":
          case "command":
            return "Meta";
          default:
            return "Ctrl";
        }
      });
      if (!key)
        return null;
      return {
        modifiers,
        key: key.toUpperCase()
      };
    } catch (error) {
      console.error("\u89E3\u6790\u5FEB\u6377\u952E\u5931\u8D25:", error);
      return null;
    }
  }
  static formatHotkey(hotkey) {
    const modifiers = hotkey.modifiers.map((mod) => {
      switch (mod) {
        case "Ctrl":
          return "Ctrl";
        case "Alt":
          return "Alt";
        case "Shift":
          return "Shift";
        case "Meta":
          return "Cmd";
        default:
          return mod;
      }
    });
    return [...modifiers, hotkey.key].join("+");
  }
  checkHotkeyConflict(hotkey) {
    console.log("HotkeyManager: \u8DF3\u8FC7\u5FEB\u6377\u952E\u51B2\u7A81\u68C0\u67E5");
    return false;
  }
  getRegisteredHotkeys() {
    return new Map(this.registeredHotkeys);
  }
  setHotkeyEnabled(hotkeyId, enabled) {
    const hotkey = this.registeredHotkeys.get(hotkeyId);
    if (hotkey) {
      if (enabled) {
        console.log(`HotkeyManager: \u542F\u7528\u5FEB\u6377\u952E ${hotkeyId}`);
      } else {
        console.log(`HotkeyManager: \u7981\u7528\u5FEB\u6377\u952E ${hotkeyId}`);
      }
    }
  }
};

// src/ui/FloatingPanel.ts
var import_obsidian4 = __toModule(require("obsidian"));
var FloatingPanel = class {
  constructor(view, options) {
    this.filteredFiles = [];
    this.selectedIndex = 0;
    this.floatingTocWrapper = null;
    this.view = view;
    this.options = options;
    this.filteredFiles = this.getFilteredFiles();
    this.selectedIndex = Math.min(options.settings.selectedFileIndex || 0, this.filteredFiles.length - 1);
    this.boundHandleKeyDown = this.handleKeyDown.bind(this);
    this.boundHandleContainerClick = this.handleContainerClick.bind(this);
    this.render();
    this.addEventListeners();
  }
  update(options) {
    console.log("FloatingPanel.update called with options:", options);
    this.options = { ...this.options, ...options };
    this.filteredFiles = this.getFilteredFiles();
    console.log("Filtered files count:", this.filteredFiles.length);
    if (this.floatingTocWrapper && this.floatingTocWrapper.parentNode) {
      this.updateContent();
    } else {
      this.render();
    }
  }
  destroy() {
    this.removeEventListeners();
    if (this.floatingTocWrapper) {
      this.floatingTocWrapper.remove();
      this.floatingTocWrapper = null;
    }
  }
  getFilteredFiles() {
    const { files, selectedFiles } = this.options;
    console.log("getFilteredFiles - files count:", files.length, "selectedFiles:", selectedFiles);
    const filtered = files.filter((file) => selectedFiles.includes(file.path));
    console.log("getFilteredFiles - filtered count:", filtered.length);
    return filtered;
  }
  addEventListeners() {
    document.addEventListener("keydown", this.boundHandleKeyDown);
    if (this.floatingTocWrapper) {
      this.floatingTocWrapper.addEventListener("click", this.boundHandleContainerClick);
    }
  }
  removeEventListeners() {
    document.removeEventListener("keydown", this.boundHandleKeyDown);
    if (this.floatingTocWrapper) {
      this.floatingTocWrapper.removeEventListener("click", this.boundHandleContainerClick);
    }
  }
  handleKeyDown(event) {
    if (!this.options.panelState.isVisible)
      return;
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        this.selectedIndex = this.selectedIndex > 0 ? this.selectedIndex - 1 : this.filteredFiles.length - 1;
        this.updateSelection();
        break;
      case "ArrowDown":
        event.preventDefault();
        this.selectedIndex = this.selectedIndex < this.filteredFiles.length - 1 ? this.selectedIndex + 1 : 0;
        this.updateSelection();
        break;
      case "Enter":
        event.preventDefault();
        if (this.filteredFiles[this.selectedIndex]) {
          this.options.onFileSelect(this.filteredFiles[this.selectedIndex].path);
        }
        break;
      case "Escape":
        event.preventDefault();
        this.options.onClose();
        break;
    }
  }
  handleContainerClick(event) {
    var _a, _b, _c, _d, _e;
    const target = event.target;
    const mouseEvent = event;
    if (target.classList.contains("toolbar-btn")) {
      if ((_a = target.textContent) == null ? void 0 : _a.includes("\u{1F4C4}")) {
        this.options.onCreateFile();
      } else if ((_b = target.textContent) == null ? void 0 : _b.includes("\u2699\uFE0F")) {
        this.options.onOpenSettings();
      } else if ((_c = target.textContent) == null ? void 0 : _c.includes("\u{1F527}")) {
        this.options.onOrganizeContent("");
      } else if (((_d = target.textContent) == null ? void 0 : _d.includes("\u{1F4CC}")) || ((_e = target.textContent) == null ? void 0 : _e.includes("\u{1F4CD}"))) {
        this.options.onToggleFixed();
      }
    }
    const fileItem = target.closest(".heading-list-item");
    if (fileItem && !fileItem.classList.contains("empty-content")) {
      const filePath = fileItem.getAttribute("data-path");
      if (filePath) {
        this.updateSelectedFile(filePath);
        if (mouseEvent.ctrlKey) {
          this.options.onFileOpenInSplit(filePath);
        }
      }
    }
  }
  updateSelectedFile(filePath) {
    var _a, _b;
    const index = this.filteredFiles.findIndex((file) => file.path === filePath);
    if (index !== -1) {
      this.selectedIndex = index;
    }
    const allItems = (_a = this.floatingTocWrapper) == null ? void 0 : _a.querySelectorAll(".heading-list-item");
    allItems == null ? void 0 : allItems.forEach((item) => {
      item.classList.remove("selected");
    });
    const currentItem = (_b = this.floatingTocWrapper) == null ? void 0 : _b.querySelector(`[data-path="${filePath}"]`);
    if (currentItem) {
      currentItem.classList.add("selected");
    }
    this.saveSelectedIndex();
  }
  updateSelection() {
    if (!this.floatingTocWrapper)
      return;
    const items = this.floatingTocWrapper.querySelectorAll(".heading-list-item");
    items.forEach((item, index) => {
      if (index === this.selectedIndex) {
        item.classList.add("selected");
      } else {
        item.classList.remove("selected");
      }
    });
    this.saveSelectedIndex();
  }
  saveSelectedIndex() {
    if (this.options.onSelectionChange) {
      this.options.onSelectionChange(this.selectedIndex);
    }
  }
  render() {
    var _a, _b, _c, _d, _e;
    const { panelState, settings } = this.options;
    const { filteredFiles } = this;
    if (this.selectedIndex === 0 && filteredFiles.length > 0) {
      this.selectedIndex = 0;
    }
    console.log("FloatingPanel.render called, panelState.isVisible:", panelState.isVisible, "panelState.isFixed:", panelState.isFixed);
    const existingPanel = (_a = this.view.contentEl) == null ? void 0 : _a.querySelector(".floating-toc-div");
    if (existingPanel && existingPanel !== this.floatingTocWrapper) {
      existingPanel.remove();
    }
    if (this.floatingTocWrapper && this.floatingTocWrapper.parentNode) {
      this.updateContent();
      return;
    }
    if (this.floatingTocWrapper) {
      this.floatingTocWrapper.remove();
    }
    this.floatingTocWrapper = document.createElement("div");
    this.floatingTocWrapper.addClass("floating-toc-div");
    this.floatingTocWrapper.addClass("floating-right");
    if (!document.body.classList.contains("enable-bar-heading-text")) {
      document.body.addClass("enable-bar-heading-text");
    }
    if (panelState.isFixed) {
      this.floatingTocWrapper.addClass("pin");
      console.log("Added pin class to floating panel");
    } else {
      this.floatingTocWrapper.removeClass("pin");
      console.log("Removed pin class from floating panel");
    }
    const toolbar = this.floatingTocWrapper.createEl("div");
    toolbar.addClass("toolbar");
    this.createToolbar(toolbar);
    const ulDom = this.floatingTocWrapper.createEl("ul");
    ulDom.addClass("floating-toc");
    console.log("Rendering file list, filteredFiles.length:", filteredFiles.length);
    if (filteredFiles.length === 0) {
      console.log("Rendering empty state");
      const emptyLi = ulDom.createEl("li");
      emptyLi.addClass("heading-list-item");
      emptyLi.addClass("empty-content");
      emptyLi.setAttribute("data-level", "1");
      emptyLi.setAttribute("data-id", "empty");
      const emptyTextDom = emptyLi.createEl("div");
      emptyTextDom.addClass("text-wrap");
      const emptyText = emptyTextDom.createEl("div");
      emptyText.addClass("text");
      emptyText.textContent = "\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u6DFB\u52A0\u6587\u4EF6\u5230\u5217\u8868";
      const emptyLineDom = emptyLi.createEl("div");
      emptyLineDom.addClass("line-wrap");
      emptyLineDom.createDiv().addClass("line");
    } else {
      console.log("Rendering file list with", filteredFiles.length, "files");
      filteredFiles.forEach((file, index) => {
        const fileLi = ulDom.createEl("li");
        fileLi.addClass("heading-list-item");
        fileLi.setAttribute("data-level", "1");
        fileLi.setAttribute("data-id", index.toString());
        fileLi.setAttribute("data-path", file.path);
        if (index === this.selectedIndex) {
          fileLi.addClass("selected");
        }
        const textDom = fileLi.createEl("div");
        textDom.addClass("text-wrap");
        const text = textDom.createEl("div");
        text.addClass("text");
        text.textContent = settings.showFileExtensions ? file.name : file.basename;
        const lineDom = fileLi.createEl("div");
        lineDom.addClass("line-wrap");
        lineDom.createDiv().addClass("line");
      });
    }
    const insertResult = ((_c = (_b = this.view.contentEl) == null ? void 0 : _b.querySelector(".markdown-source-view")) == null ? void 0 : _c.insertAdjacentElement("beforebegin", this.floatingTocWrapper)) || ((_e = (_d = this.view.contentEl) == null ? void 0 : _d.querySelector(".markdown-reading-view")) == null ? void 0 : _e.insertAdjacentElement("beforebegin", this.floatingTocWrapper));
    if (!insertResult) {
      console.error("Failed to insert floating panel");
      return;
    }
    this.addEventListeners();
  }
  updateContent() {
    if (!this.floatingTocWrapper)
      return;
    const { panelState, settings } = this.options;
    const { filteredFiles } = this;
    const currentSelectedItem = this.floatingTocWrapper.querySelector(".heading-list-item.selected");
    const currentSelectedPath = currentSelectedItem == null ? void 0 : currentSelectedItem.getAttribute("data-path");
    if (currentSelectedPath) {
      const index = filteredFiles.findIndex((file) => file.path === currentSelectedPath);
      if (index !== -1) {
        this.selectedIndex = index;
      } else {
        this.selectedIndex = 0;
      }
    } else {
      if (this.selectedIndex >= filteredFiles.length) {
        this.selectedIndex = 0;
      }
    }
    if (panelState.isFixed) {
      this.floatingTocWrapper.addClass("pin");
    } else {
      this.floatingTocWrapper.removeClass("pin");
    }
    const toolbar = this.floatingTocWrapper.querySelector(".toolbar");
    if (toolbar) {
      this.updateToolbar(toolbar);
    }
    const ulDom = this.floatingTocWrapper.querySelector(".floating-toc");
    if (ulDom) {
      ulDom.innerHTML = "";
      if (filteredFiles.length === 0) {
        const emptyLi = ulDom.createEl("li");
        emptyLi.addClass("heading-list-item");
        emptyLi.addClass("empty-content");
        emptyLi.setAttribute("data-level", "1");
        emptyLi.setAttribute("data-id", "empty");
        const emptyTextDom = emptyLi.createEl("div");
        emptyTextDom.addClass("text-wrap");
        const emptyText = emptyTextDom.createEl("div");
        emptyText.addClass("text");
        emptyText.textContent = "\u8BF7\u5728\u8BBE\u7F6E\u4E2D\u6DFB\u52A0\u6587\u4EF6\u5230\u5217\u8868";
        const emptyLineDom = emptyLi.createEl("div");
        emptyLineDom.addClass("line-wrap");
        emptyLineDom.createDiv().addClass("line");
      } else {
        filteredFiles.forEach((file, index) => {
          const fileLi = ulDom.createEl("li");
          fileLi.addClass("heading-list-item");
          fileLi.setAttribute("data-level", "1");
          fileLi.setAttribute("data-id", index.toString());
          fileLi.setAttribute("data-path", file.path);
          if (index === this.selectedIndex) {
            fileLi.addClass("selected");
          }
          const textDom = fileLi.createEl("div");
          textDom.addClass("text-wrap");
          const text = textDom.createEl("div");
          text.addClass("text");
          text.textContent = settings.showFileExtensions ? file.name : file.basename;
          const lineDom = fileLi.createEl("div");
          lineDom.addClass("line-wrap");
          lineDom.createDiv().addClass("line");
        });
      }
    }
  }
  createToolbar(toolbar) {
    const buttons = [
      { icon: "\u{1F4C4}", title: "\u65B0\u5EFA\u6587\u4EF6", onClick: () => this.options.onCreateFile() },
      { icon: "\u2699\uFE0F", title: "\u6253\u5F00\u8BBE\u7F6E", onClick: () => this.options.onOpenSettings() },
      { icon: "\u{1F527}", title: "\u6574\u7406\u6587\u4EF6\u5185\u5BB9", onClick: () => this.organizeCurrentFile() },
      { icon: this.options.panelState.isFixed ? "\u{1F4CC}" : "\u{1F4CD}", title: this.options.panelState.isFixed ? "\u53D6\u6D88\u56FA\u5B9A" : "\u56FA\u5B9A\u4F4D\u7F6E", onClick: () => this.options.onToggleFixed() }
    ];
    buttons.forEach((btn) => {
      const button = toolbar.createEl("button");
      button.addClass("toolbar-btn");
      button.innerHTML = btn.icon;
      button.title = btn.title;
      button.onclick = btn.onClick;
    });
  }
  organizeCurrentFile() {
    var _a;
    const currentSelectedItem = (_a = this.floatingTocWrapper) == null ? void 0 : _a.querySelector(".heading-list-item.selected");
    if (currentSelectedItem) {
      const filePath = currentSelectedItem.getAttribute("data-path");
      if (filePath) {
        this.options.onOrganizeContent(filePath);
      } else {
        new import_obsidian4.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u6587\u4EF6");
      }
    } else {
      new import_obsidian4.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u6587\u4EF6");
    }
  }
  updateToolbar(toolbar) {
    const pinButton = toolbar.querySelector(".toolbar-btn:nth-child(4)");
    if (pinButton) {
      pinButton.innerHTML = this.options.panelState.isFixed ? "\u{1F4CC}" : "\u{1F4CD}";
      pinButton.title = this.options.panelState.isFixed ? "\u53D6\u6D88\u56FA\u5B9A" : "\u56FA\u5B9A\u4F4D\u7F6E";
    }
  }
};

// main.ts
var CreateFileModal = class extends import_obsidian5.Modal {
  constructor(app, plugin) {
    super(app);
    this.plugin = plugin;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("obsidian-smartpaste-create-file-modal");
    const title = contentEl.createEl("h2", { text: "\u521B\u5EFA\u65B0\u6587\u4EF6" });
    title.style.marginBottom = "20px";
    const folderContainer = contentEl.createEl("div");
    folderContainer.style.marginBottom = "15px";
    const folderLabel = folderContainer.createEl("label", { text: "\u9009\u62E9\u6587\u4EF6\u5939:" });
    folderLabel.style.display = "block";
    folderLabel.style.marginBottom = "5px";
    folderLabel.style.fontWeight = "500";
    const folderSelect = folderContainer.createEl("select");
    folderSelect.style.width = "100%";
    folderSelect.style.padding = "8px";
    folderSelect.style.border = "1px solid var(--background-modifier-border)";
    folderSelect.style.borderRadius = "4px";
    folderSelect.style.backgroundColor = "var(--background-primary)";
    folderSelect.style.color = "var(--text-normal)";
    const rootOption = folderSelect.createEl("option");
    rootOption.value = "";
    rootOption.textContent = "\u6839\u76EE\u5F55";
    const folders = this.plugin.fileManager.getFolders();
    const sortedFolders = folders.sort((a, b) => a.path.localeCompare(b.path));
    const folderTree = this.buildFolderTree(sortedFolders);
    this.renderFolderOptions(folderSelect, folderTree);
    const nameContainer = contentEl.createEl("div");
    nameContainer.style.marginBottom = "20px";
    const nameLabel = nameContainer.createEl("label", { text: "\u6587\u4EF6\u540D:" });
    nameLabel.style.display = "block";
    nameLabel.style.marginBottom = "5px";
    nameLabel.style.fontWeight = "500";
    const nameInput = nameContainer.createEl("input", {
      type: "text"
    });
    nameInput.setAttribute("placeholder", "\u6587\u4EF6\u540D\uFF08\u4E0D\u9700\u8981.md\u6269\u5C55\u540D\uFF09");
    nameInput.style.width = "100%";
    nameInput.style.padding = "8px";
    nameInput.style.border = "1px solid var(--background-modifier-border)";
    nameInput.style.borderRadius = "4px";
    nameInput.style.backgroundColor = "var(--background-primary)";
    nameInput.style.color = "var(--text-normal)";
    const buttonContainer = contentEl.createEl("div");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    const createButton = buttonContainer.createEl("button", { text: "\u521B\u5EFA\u6587\u4EF6" });
    createButton.style.padding = "8px 16px";
    createButton.style.backgroundColor = "var(--interactive-accent)";
    createButton.style.color = "var(--text-on-accent)";
    createButton.style.border = "none";
    createButton.style.borderRadius = "4px";
    createButton.style.cursor = "pointer";
    const cancelButton = buttonContainer.createEl("button", { text: "\u53D6\u6D88" });
    cancelButton.style.padding = "8px 16px";
    cancelButton.style.backgroundColor = "var(--background-secondary)";
    cancelButton.style.color = "var(--text-normal)";
    cancelButton.style.border = "1px solid var(--background-modifier-border)";
    cancelButton.style.borderRadius = "4px";
    cancelButton.style.cursor = "pointer";
    createButton.onclick = async () => {
      const selectedFolder = folderSelect.value;
      const name = nameInput.value.trim();
      if (!name) {
        new import_obsidian5.Notice("\u8BF7\u8F93\u5165\u6587\u4EF6\u540D");
        return;
      }
      let fullPath = "";
      if (selectedFolder) {
        fullPath = `${selectedFolder}/${name}.md`;
      } else {
        fullPath = `${name}.md`;
      }
      try {
        const file = await this.plugin.fileManager.createNewFile(selectedFolder, name);
        if (file) {
          new import_obsidian5.Notice(`\u6587\u4EF6 ${fullPath} \u521B\u5EFA\u6210\u529F`);
          if (!this.plugin.settings.selectedFiles.includes(fullPath)) {
            this.plugin.settings.selectedFiles.push(fullPath);
            await this.plugin.saveSettings();
            await this.plugin.loadFileList();
            this.plugin.updateFloatingPanel();
          }
          this.close();
        } else {
          new import_obsidian5.Notice("\u521B\u5EFA\u6587\u4EF6\u5931\u8D25");
        }
      } catch (error) {
        console.error("\u521B\u5EFA\u6587\u4EF6\u5931\u8D25:", error);
        new import_obsidian5.Notice("\u521B\u5EFA\u6587\u4EF6\u5931\u8D25");
      }
    };
    cancelButton.onclick = () => {
      this.close();
    };
    const handleKeyPress = (event) => {
      if (event.key === "Enter") {
        createButton.click();
      }
    };
    nameInput.addEventListener("keypress", handleKeyPress);
  }
  buildFolderTree(folders) {
    const folderMap = new Map();
    const rootFolders = [];
    folders.forEach((folder) => {
      folderMap.set(folder.path, {
        path: folder.path,
        name: folder.name,
        children: []
      });
    });
    folders.forEach((folder) => {
      const folderNode = folderMap.get(folder.path);
      const parentPath = this.getParentPath(folder.path);
      if (parentPath && folderMap.has(parentPath)) {
        const parentNode = folderMap.get(parentPath);
        parentNode.children.push(folderNode);
      } else {
        rootFolders.push(folderNode);
      }
    });
    return rootFolders;
  }
  renderFolderOptions(select, folderTree, level = 0) {
    folderTree.forEach((folder) => {
      const option = select.createEl("option");
      option.value = folder.path;
      option.textContent = "\u3000".repeat(level) + folder.name;
      if (folder.children.length > 0) {
        this.renderFolderOptions(select, folder.children, level + 1);
      }
    });
  }
  getParentPath(path) {
    const lastSlashIndex = path.lastIndexOf("/");
    return lastSlashIndex > 0 ? path.substring(0, lastSlashIndex) : null;
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var ObsidianCutPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.floatingPanel = null;
    this.panelState = {
      isVisible: false,
      isFixed: false,
      position: { x: 100, y: 100 },
      selectedIndex: 0,
      searchText: ""
    };
    this.selectedContent = "";
    this.allFiles = [];
  }
  async onload() {
    console.log("Loading Obsidian SmartPaste plugin");
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    this.fileManager = new FileManager(this.app);
    this.hotkeyManager = new HotkeyManager(this.app, this.settings);
    this.addSettingTab(new ObsidianCutSettingTab(this.app, this));
    this.hotkeyManager.registerHotkeys();
    this.registerCopyToFileHotkey();
    this.registerEventListeners();
    await this.loadFileList();
    this.initializeFloatingPanel();
    if (this.settings.selectedFiles.length > 0) {
      this.showFloatingPanel();
    }
    console.log("Obsidian SmartPaste plugin loaded successfully");
  }
  onunload() {
    console.log("Unloading Obsidian SmartPaste plugin");
    if (this.floatingPanel) {
      this.floatingPanel.destroy();
      this.floatingPanel = null;
    }
    this.hotkeyManager.unregisterHotkeys();
    this.removeEventListeners();
    console.log("Obsidian SmartPaste plugin unloaded");
  }
  registerEventListeners() {
    this.registerDomEvent(document, "selectionchange", this.handleSelectionChange.bind(this));
    this.registerDomEvent(document, "mousemove", this.handleMouseMove.bind(this));
    this.registerDomEvent(document, "keydown", this.handleKeyDown.bind(this));
    this.app.workspace.on("file-open", this.handleFileOpen.bind(this));
    this.app.workspace.on("active-leaf-change", this.handleActiveLeafChange.bind(this));
  }
  removeEventListeners() {
  }
  registerCopyToFileHotkey() {
    this.addCommand({
      id: "copy-to-selected-file",
      name: "\u590D\u5236\u9009\u4E2D\u5185\u5BB9\u5230\u9AD8\u4EAE\u6587\u4EF6",
      hotkeys: this.parseHotkey(this.settings.copyToFileHotkey),
      callback: () => {
        this.copySelectedContentToFile();
      }
    });
  }
  reregisterCopyToFileHotkey() {
    this.addCommand({
      id: "copy-to-selected-file",
      name: "\u590D\u5236\u9009\u4E2D\u5185\u5BB9\u5230\u9AD8\u4EAE\u6587\u4EF6",
      hotkeys: this.parseHotkey(this.settings.copyToFileHotkey),
      callback: () => {
        this.copySelectedContentToFile();
      }
    });
  }
  parseHotkey(hotkeyString) {
    if (!hotkeyString || !hotkeyString.trim()) {
      return [{ modifiers: ["Ctrl", "Shift"], key: "X" }];
    }
    const parts = hotkeyString.split("+").map((part) => part.trim());
    const key = parts[parts.length - 1];
    const modifiers = parts.slice(0, -1);
    return [{
      modifiers: modifiers.map((mod) => {
        switch (mod.toLowerCase()) {
          case "ctrl":
            return "Ctrl";
          case "cmd":
          case "command":
            return "Mod";
          case "alt":
            return "Alt";
          case "shift":
            return "Shift";
          default:
            return "Ctrl";
        }
      }),
      key: key.toUpperCase()
    }];
  }
  async copySelectedContentToFile() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView) {
      new import_obsidian5.Notice("\u6CA1\u6709\u6D3B\u52A8\u7684\u7F16\u8F91\u5668");
      return;
    }
    const selection = activeView.editor.getSelection();
    if (!selection || !selection.trim()) {
      new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u590D\u5236\u7684\u5185\u5BB9");
      return;
    }
    if (!this.floatingPanel) {
      new import_obsidian5.Notice("\u8BF7\u5148\u6253\u5F00\u60AC\u6D6E\u680F");
      return;
    }
    const selectedFiles = this.settings.selectedFiles;
    if (selectedFiles.length === 0) {
      new import_obsidian5.Notice("\u6CA1\u6709\u9009\u62E9\u4EFB\u4F55\u6587\u4EF6");
      return;
    }
    const highlightedFile = this.getHighlightedFile();
    if (!highlightedFile) {
      new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u76EE\u6807\u6587\u4EF6");
      return;
    }
    try {
      console.log("copySelectedContentToFile - \u539F\u59CB\u9009\u62E9\u5185\u5BB9:", selection);
      console.log("copySelectedContentToFile - \u5F53\u524D\u683C\u5F0F\u8BBE\u7F6E:", this.settings.pasteFormat);
      let existingContent = "";
      try {
        existingContent = await this.fileManager.readFileContent(highlightedFile) || "";
        console.log("copySelectedContentToFile - \u76EE\u6807\u6587\u4EF6\u73B0\u6709\u5185\u5BB9\u957F\u5EA6:", existingContent.length);
      } catch (error) {
        console.log("copySelectedContentToFile - \u65E0\u6CD5\u8BFB\u53D6\u76EE\u6807\u6587\u4EF6\u5185\u5BB9\uFF0C\u4F7F\u7528\u7A7A\u5185\u5BB9");
      }
      const formattedContent = ContentFormatter.formatContentWithContinuousNumbering(selection, {
        format: this.settings.pasteFormat,
        customTemplate: void 0,
        addTimestamp: false,
        addSource: false
      }, existingContent);
      console.log("copySelectedContentToFile - \u683C\u5F0F\u5316\u540E\u5185\u5BB9:", formattedContent);
      const success = await this.fileManager.appendToFile(highlightedFile, formattedContent);
      if (success) {
        new import_obsidian5.Notice(`\u5185\u5BB9\u5DF2\u590D\u5236\u5230 ${highlightedFile}`);
      } else {
        new import_obsidian5.Notice("\u590D\u5236\u5931\u8D25");
      }
    } catch (error) {
      console.error("\u590D\u5236\u5185\u5BB9\u5931\u8D25:", error);
      new import_obsidian5.Notice("\u590D\u5236\u5931\u8D25");
    }
  }
  getHighlightedFile() {
    if (!this.floatingPanel)
      return null;
    const selectedElement = document.querySelector(".floating-toc-div .heading-list-item.selected");
    if (selectedElement) {
      const filePath = selectedElement.getAttribute("data-path");
      return filePath;
    }
    return this.settings.selectedFiles[0] || null;
  }
  async handleSelectionChange() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!activeView)
      return;
    const editor = activeView.editor;
    const selection = editor.getSelection();
    console.log("Selection changed:", selection ? selection.substring(0, 50) + "..." : "no selection");
    if (selection && selection.trim() && selection !== this.selectedContent) {
      this.selectedContent = selection;
      console.log("Selected content:", this.selectedContent.substring(0, 50) + "...");
      if (this.settings.autoShowPanel && !this.panelState.isFixed) {
        console.log("Showing floating panel...");
        this.showFloatingPanel();
      }
    } else if (!selection && this.selectedContent) {
      this.selectedContent = "";
      console.log("Cleared selected content");
      if (!this.panelState.isFixed) {
        console.log("Hiding floating panel...");
        this.hideFloatingPanel();
      }
    }
  }
  handleMouseMove(event) {
    if (!this.settings.autoShowPanel || this.panelState.isFixed)
      return;
    if (this.panelState.isVisible) {
      const container = document.getElementById("obsidian-smartpaste-panel-container");
      if (container) {
        const panel = container.querySelector(".obsidian-smartpaste-panel");
        if (panel) {
          const rect = panel.getBoundingClientRect();
          const mouseX = event.clientX;
          const mouseY = event.clientY;
          if (mouseX < rect.left - 50 || mouseX > rect.right + 50 || mouseY < rect.top - 50 || mouseY > rect.bottom + 50) {
            this.hideFloatingPanel();
          }
        }
      }
    }
  }
  handleKeyDown(event) {
    if (event.ctrlKey && event.shiftKey && event.key === "C") {
      event.preventDefault();
      this.toggleFloatingPanel();
    }
  }
  handleFileOpen() {
    this.loadFileList();
  }
  handleActiveLeafChange() {
    if (this.floatingPanel) {
      this.floatingPanel.destroy();
      this.floatingPanel = null;
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (view) {
      this.initializeFloatingPanel();
    }
  }
  async loadFileList() {
    try {
      this.allFiles = await this.fileManager.getAllFiles();
      this.allFiles = this.fileManager.sortFiles(this.allFiles, this.settings.fileSortOrder);
      this.updateFloatingPanel();
    } catch (error) {
      console.error("\u52A0\u8F7D\u6587\u4EF6\u5217\u8868\u5931\u8D25:", error);
    }
  }
  initializeFloatingPanel() {
    console.log("Initializing floating panel...");
    this.app.workspace.onLayoutReady(() => {
      this.createFloatingPanel();
    });
  }
  createFloatingPanel() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian5.MarkdownView);
    if (!view) {
      console.error("No active markdown view found");
      return;
    }
    this.panelState.position = this.settings.panelPosition;
    this.panelState.isFixed = this.settings.fixedPanel;
    if (this.panelState.isFixed) {
      this.panelState.isVisible = true;
      console.log("Panel is fixed, setting it to visible");
    }
    console.log("createFloatingPanel: panelState.isFixed from settings:", this.panelState.isFixed);
    console.log("createFloatingPanel: panelState.isVisible:", this.panelState.isVisible);
    const panelOptions = {
      files: this.allFiles,
      selectedFiles: this.settings.selectedFiles,
      panelState: this.panelState,
      settings: this.settings,
      onFileSelect: this.selectFile.bind(this),
      onFileOpen: this.openFile.bind(this),
      onFileOpenInSplit: this.openFileInSplit.bind(this),
      onToggleFixed: this.toggleFixed.bind(this),
      onOpenSettings: this.openSettings.bind(this),
      onOrganizeContent: this.organizeContent.bind(this),
      onCreateFile: this.createNewFile.bind(this),
      onClose: this.hideFloatingPanel.bind(this),
      onSortChange: this.handleSortChange.bind(this),
      onPositionChange: this.handlePositionChange.bind(this),
      onSelectionChange: this.handleFileSelectionChange.bind(this)
    };
    this.floatingPanel = new FloatingPanel(view, panelOptions);
    console.log("Floating panel initialized with new component");
  }
  showFloatingPanel() {
    console.log("showFloatingPanel called, current state:", this.panelState.isVisible);
    if (this.panelState.isVisible)
      return;
    this.panelState.isVisible = true;
    console.log("Panel state set to visible");
    this.updateFloatingPanel();
  }
  hideFloatingPanel() {
    if (this.panelState.isFixed) {
      console.log("Panel is fixed, not hiding");
      return;
    }
    if (!this.panelState.isVisible)
      return;
    this.panelState.isVisible = false;
    this.updateFloatingPanel();
  }
  toggleFloatingPanel() {
    console.log("toggleFloatingPanel called, current state:", this.panelState.isVisible);
    if (this.panelState.isVisible) {
      console.log("Panel is visible, hiding it");
      this.hideFloatingPanel();
    } else {
      console.log("Panel is hidden, showing it");
      this.showFloatingPanel();
    }
  }
  sortSelectedFiles(selectedFiles) {
    const files = selectedFiles.map((path) => this.allFiles.find((f) => f.path === path)).filter(Boolean);
    switch (this.settings.fileSortOrder) {
      case "name":
        return files.sort((a, b) => a.name.localeCompare(b.name)).map((f) => f.path);
      case "modified":
        return files.sort((a, b) => b.modifiedTime - a.modifiedTime).map((f) => f.path);
      case "created":
        return files.sort((a, b) => b.createdTime - a.createdTime).map((f) => f.path);
      default:
        return selectedFiles;
    }
  }
  async selectFile(filePath) {
    if (!this.selectedContent) {
      new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u8981\u590D\u5236\u7684\u5185\u5BB9");
      return;
    }
    try {
      const formattedContent = ContentFormatter.formatContent(this.selectedContent, {
        format: this.settings.pasteFormat
      });
      const success = await this.fileManager.appendToFile(filePath, formattedContent);
      if (success) {
        new import_obsidian5.Notice(`\u5185\u5BB9\u5DF2\u6210\u529F\u6DFB\u52A0\u5230 ${this.getFileName(filePath)}`);
        if (!this.settings.selectedFiles.includes(filePath)) {
          this.settings.selectedFiles.push(filePath);
          await this.saveSettings();
          this.updateFloatingPanel();
        }
      } else {
        new import_obsidian5.Notice("\u6DFB\u52A0\u5185\u5BB9\u5931\u8D25");
      }
    } catch (error) {
      console.error("\u9009\u62E9\u6587\u4EF6\u5931\u8D25:", error);
      new import_obsidian5.Notice("\u64CD\u4F5C\u5931\u8D25");
    }
  }
  openFile(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      this.app.workspace.openLinkText(filePath, "", false, { active: true });
    }
  }
  openFileInSplit(filePath) {
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian5.TFile) {
      const leaf = this.app.workspace.splitActiveLeaf("vertical");
      if (leaf) {
        leaf.openFile(file);
      }
    }
  }
  async createNewFile() {
    const modal = new CreateFileModal(this.app, this);
    modal.open();
  }
  toggleFixed() {
    console.log("toggleFixed called, current isFixed:", this.panelState.isFixed);
    this.panelState.isFixed = !this.panelState.isFixed;
    this.settings.fixedPanel = this.panelState.isFixed;
    console.log("toggleFixed: new isFixed:", this.panelState.isFixed);
    if (this.panelState.isFixed && !this.panelState.isVisible) {
      this.panelState.isVisible = true;
      console.log("Panel set to fixed, making it visible");
    }
    this.saveSettings();
    if (this.floatingPanel) {
      this.floatingPanel.destroy();
      this.floatingPanel = null;
    }
    this.initializeFloatingPanel();
    new import_obsidian5.Notice(this.panelState.isFixed ? "\u60AC\u6D6E\u7A97\u5DF2\u56FA\u5B9A" : "\u60AC\u6D6E\u7A97\u5DF2\u53D6\u6D88\u56FA\u5B9A");
  }
  openSettings() {
    this.app.setting.open();
    this.app.setting.openTabById(this.manifest.id);
  }
  async organizeContent(filePath) {
    if (!filePath) {
      new import_obsidian5.Notice("\u8BF7\u5148\u9009\u62E9\u4E00\u4E2A\u6587\u4EF6");
      return;
    }
    try {
      console.log("\u5F00\u59CB\u6574\u7406\u6587\u4EF6:", filePath);
      const content = await this.fileManager.readFileContent(filePath);
      console.log("\u539F\u59CB\u5185\u5BB9\u957F\u5EA6:", content.length);
      if (content) {
        if (!this.settings.contentSortRules.enabled) {
          console.log("\u5185\u5BB9\u6574\u7406\u529F\u80FD\u672A\u542F\u7528\uFF0C\u4F7F\u7528\u9ED8\u8BA4\u89C4\u5219");
          const defaultRules = {
            sortBy: "alphabetical",
            removeDuplicates: true,
            trimWhitespace: true
          };
          const organizedContent = ContentFormatter.organizeContent(content, defaultRules);
          console.log("\u6574\u7406\u540E\u5185\u5BB9\u957F\u5EA6:", organizedContent.length);
          const success = await this.fileManager.replaceFileContent(filePath, organizedContent);
          if (success) {
            new import_obsidian5.Notice("\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u5B8C\u6210");
            console.log("\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u6210\u529F");
          } else {
            new import_obsidian5.Notice("\u6574\u7406\u6587\u4EF6\u5185\u5BB9\u5931\u8D25");
            console.log("\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u5931\u8D25");
          }
        } else {
          console.log("\u4F7F\u7528\u7528\u6237\u8BBE\u7F6E\u7684\u5185\u5BB9\u6574\u7406\u89C4\u5219");
          const organizedContent = ContentFormatter.organizeContent(content, this.settings.contentSortRules);
          console.log("\u6574\u7406\u540E\u5185\u5BB9\u957F\u5EA6:", organizedContent.length);
          const success = await this.fileManager.replaceFileContent(filePath, organizedContent);
          if (success) {
            new import_obsidian5.Notice("\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u5B8C\u6210");
            console.log("\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u6210\u529F");
          } else {
            new import_obsidian5.Notice("\u6574\u7406\u6587\u4EF6\u5185\u5BB9\u5931\u8D25");
            console.log("\u6587\u4EF6\u5185\u5BB9\u6574\u7406\u5931\u8D25");
          }
        }
      } else {
        new import_obsidian5.Notice("\u6587\u4EF6\u4E3A\u7A7A\u6216\u8BFB\u53D6\u5931\u8D25");
        console.log("\u6587\u4EF6\u4E3A\u7A7A\u6216\u8BFB\u53D6\u5931\u8D25");
      }
    } catch (error) {
      console.error("\u6574\u7406\u6587\u4EF6\u5185\u5BB9\u5931\u8D25:", error);
      new import_obsidian5.Notice("\u6574\u7406\u6587\u4EF6\u5185\u5BB9\u5931\u8D25");
    }
  }
  async handleSortChange(sortOrder) {
    this.settings.fileSortOrder = sortOrder;
    await this.saveSettings();
    await this.loadFileList();
    this.updateFloatingPanel();
  }
  updateFloatingPanel() {
    console.log("updateFloatingPanel called, floatingPanel:", !!this.floatingPanel);
    document.documentElement.style.setProperty("--panel-width", `${this.settings.panelWidth}px`);
    if (this.floatingPanel) {
      console.log("Updating floating panel with state:", this.panelState);
      this.floatingPanel.update({
        files: this.allFiles,
        selectedFiles: this.settings.selectedFiles,
        panelState: this.panelState,
        settings: this.settings
      });
    } else {
      console.log("FloatingPanel is null, cannot update");
    }
  }
  handlePositionChange(position) {
    this.panelState.position = position;
    this.settings.panelPosition = position;
    this.saveSettings();
  }
  handleFileSelectionChange(index) {
    this.settings.selectedFileIndex = index;
    this.saveSettings();
  }
  formatFileSize(bytes) {
    if (bytes === 0)
      return "0 B";
    const k = 1024;
    const sizes = ["B", "KB", "MB", "GB"];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + " " + sizes[i];
  }
  getRelativeTime(timestamp) {
    const now = Date.now();
    const diff = now - timestamp;
    const minutes = Math.floor(diff / 6e4);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    if (days > 0)
      return `${days}\u5929\u524D`;
    if (hours > 0)
      return `${hours}\u5C0F\u65F6\u524D`;
    if (minutes > 0)
      return `${minutes}\u5206\u949F\u524D`;
    return "\u521A\u521A";
  }
  getFileName(filePath) {
    const parts = filePath.split("/");
    return parts[parts.length - 1];
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
